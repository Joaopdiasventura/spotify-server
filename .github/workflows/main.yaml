name: Continuous Integration and Deployment

on:
  push:
    branches:
      - main
      - develop
      - 'release/**'
  pull_request:
    branches:
      - main
  workflow_dispatch:

env:
  DOTENV: ${{ secrets.DOTENV }}
  IMAGE_NAME: docker.io/jpplay/spotify-server

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  packages: write

jobs:
  test:
    runs-on: ubuntu-latest
    env:
      NODE_ENV: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22.x
          cache: npm
      - name: Install, Test and Build
        run: | 
            npm i
            npm run lint
            npm run test
            npm run build

  docker_push:
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    needs: test
    outputs:
      image: ${{ steps.set_image.outputs.image }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest
            type=sha,format=long
      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          push: true
          platforms: linux/amd64,linux/arm64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
      - name: Set image output
        id: set_image
        run: echo "image=${{ env.IMAGE_NAME }}:latest" >> $GITHUB_OUTPUT

  deploy:
    runs-on: self-hosted
    needs: docker_push
    env:
      NODE_ENV: production
      IMAGE_TO_DEPLOY: ${{ needs.docker_push.outputs.image }}
      IMAGE_NAME: ${{ secrets.IMAGE_NAME }}
      DOTENV: ${{ secrets.DOTENV }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      - name: Write dotenv to file
        run: |
          printf '%s\n' "$DOTENV" > .env
      - name: Export dotenv to GitHub environment
        run: |
          sed '/^\s*$/d' .env | sed '/^\s*#/d' >> $GITHUB_ENV
      - name: Login to Docker Hub
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
      - name: Pull image
        run: docker pull ${{ env.IMAGE_NAME }}:latest
      - name: Stop and remove old server container
        run: docker rm -f server || true
      - name: Stop and remove old traefik container
        run: docker rm -f traefik || true
      - name: Run server container
        run: |
          docker run -d --name server -p 3000:3000 \
            --restart=always \
            --env-file .env \
            --label "traefik.enable=true" \
            --label 'traefik.http.routers.api.rule=Host("${{ secrets.APP_DOMAIN }}")' \
            --label "traefik.http.routers.api.entrypoints=websecure" \
            --label "traefik.http.routers.api.tls.certresolver=myresolver" \
            --label "traefik.http.services.api.loadbalancer.server.port=3000" \
            ${{ env.IMAGE_NAME }}:latest
      - name: Stop and remove old traefik container
        run: docker rm -f traefik || true
      - name: Deploy traefik
        run: |
          docker run -d --name traefik -p 80:80 -p 443:443 -p 8080:8080 \
            -v "${{ github.workspace }}/traefik.yml:/etc/traefik/traefik.yml:ro" \
            -v /etc/traefik/letsencrypt:/letsencrypt \
            -v /var/run/docker.sock:/var/run/docker.sock:ro \
            traefik:v3.2
      - name: Remove unused images
        run: docker image prune -f
